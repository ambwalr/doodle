// Generated by CoffeeScript 1.6.3
(function() {
  var HEIGHT, WIDTH, antialias, body, boundboxofpoints, cacherender, dabcount, doodling, drawstroke, interpolatestroke, linearInterpolation, mouseadjust, mup, newstroke, newthing, now, penAPI, prev, renderer, renderframe, sq, stage, subnewthing, tmpdraw, transparent, vdist;

  WIDTH = 1280;

  HEIGHT = 600;

  body = $('body');

  stage = new PIXI.Stage(0xEEFFFF);

  penAPI = function() {
    return document.getElementById('wtPlugin').penAPI;
  };

  transparent = true;

  antialias = true;

  renderer = PIXI.autoDetectRenderer(WIDTH, HEIGHT, void 0, transparent, antialias);

  $(renderer.view).css({
    border: '1px solid black'
  });

  now = function() {
    return new Date().getTime();
  };

  boundboxofpoints = function(ptarr) {
    var bottom, left, right, top, xs, ys;
    xs = ptarr.map(function(n) {
      return n.x;
    });
    ys = ptarr.map(function(n) {
      return n.y;
    });
    left = xs.reduce(function(a, b) {
      return Math.min(a, b);
    });
    top = ys.reduce(function(a, b) {
      return Math.min(a, b);
    });
    right = xs.reduce(function(a, b) {
      return Math.max(a, b);
    });
    bottom = ys.reduce(function(a, b) {
      return Math.max(a, b);
    });
    return {
      left: left,
      top: top,
      right: right,
      bottom: bottom
    };
  };

  drawstroke = function(thestroke) {
    var box, grafic, prevseg, segment, strokegraf, _i, _j, _len, _len1;
    strokegraf = new PIXI.DisplayObjectContainer();
    for (_i = 0, _len = thestroke.length; _i < _len; _i++) {
      segment = thestroke[_i];
      grafic = new PIXI.Graphics();
      grafic.beginFill(0xFF0000, 0.25);
      grafic.drawCircle(segment.x, segment.y, segment.r);
      strokegraf.addChild(grafic);
    }
    prevseg = false;
    for (_j = 0, _len1 = thestroke.length; _j < _len1; _j++) {
      segment = thestroke[_j];
      if (!prevseg) {
        prevseg = {
          x: segment.x,
          y: segment.y
        };
        continue;
      }
      grafic = new PIXI.Graphics();
      grafic.lineStyle(1, 0x000000, 1);
      grafic.moveTo(prevseg.x, prevseg.y);
      grafic.lineTo(segment.x, segment.y);
      strokegraf.addChild(grafic);
      prevseg = {
        x: segment.x,
        y: segment.y
      };
    }
    box = boundboxofpoints(thestroke);
    grafic = new PIXI.Graphics();
    grafic.lineStyle(1, 0x00FF00, 0.5);
    grafic.drawRect(box.left, box.top, box.right - box.left, box.bottom - box.top);
    strokegraf.addChild(grafic);
    return strokegraf;
  };

  newstroke = [];

  tmpdraw = new PIXI.DisplayObjectContainer();

  doodling = false;

  prev = false;

  $(renderer.view).mousedown(function(e) {
    var mpos;
    mpos = mouseadjust(e, renderer.view);
    prev = {
      x: mpos.x,
      y: mpos.y
    };
    doodling = true;
    newstroke = [];
    newthing(mpos.x, mpos.y);
    return stage.addChild(tmpdraw);
  });

  mup = function(e) {
    prev = false;
    doodling = false;
    stage.addChild(drawstroke(newstroke));
    requestAnimFrame(renderframe);
    return cacherender();
  };

  sq = function(n) {
    return Math.pow(n, 2);
  };

  vdist = function(a, b) {
    var dx, dy;
    dx = Math.abs(b.x - a.x);
    dy = Math.abs(b.y - a.y);
    return Math.sqrt(sq(dx) + sq(dy));
  };

  interpolatestroke = function(thestroke) {
    var dist, freshstroke, n, prevseg, rs, segment, xs, ys, _i, _j, _len, _results;
    freshstroke = [];
    prevseg = false;
    for (_i = 0, _len = thestroke.length; _i < _len; _i++) {
      segment = thestroke[_i];
      if (!prevseg) {
        prevseg = segment;
        freshstroke.push(segment);
        continue;
      }
      dist = vdist(segment, prevseg);
      n = Math.round(dist / 10);
      n = Math.min(n, 100);
      xs = linearInterpolation(prevseg.x, segment.x, n);
      ys = linearInterpolation(prevseg.y, segment.y, n);
      rs = linearInterpolation(prevseg.r, segment.r, n);
      (function() {
        _results = [];
        for (var _j = 0; 0 <= n ? _j < n : _j > n; 0 <= n ? _j++ : _j--){ _results.push(_j); }
        return _results;
      }).apply(this).forEach(function(i) {
        return freshstroke.push({
          x: xs[i],
          y: ys[i],
          r: rs[i]
        });
      });
      if (n > 1) {
        prevseg = segment;
      }
    }
    return freshstroke;
  };

  $(renderer.view).mouseup(mup);

  $(window).mouseup(mup);

  mouseadjust = function(e, domelem) {
    var offs;
    offs = $(domelem).offset();
    return {
      x: e.pageX - offs.left,
      y: e.pageY - offs.top
    };
  };

  $(renderer.view).mousemove(function(e) {
    var mpos;
    if (doodling) {
      mpos = mouseadjust(e, renderer.view);
      if (prev) {
        newthing(mpos.x, mpos.y);
      }
      requestAnimFrame(renderframe);
      return prev = {
        x: mpos.x,
        y: mpos.y
      };
    }
  });

  body.append(renderer.view);

  linearInterpolation = function(from, to, steps) {
    var offs, _i, _results;
    steps--;
    offs = (to - from) / steps;
    return (function() {
      _results = [];
      for (var _i = 0; 0 <= steps ? _i <= steps : _i >= steps; 0 <= steps ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(function(n) {
      return from + n * offs;
    });
  };

  subnewthing = function(x, y, r) {
    var grafic;
    grafic = new PIXI.Graphics();
    grafic.beginFill(0xFF0000, 0.25);
    grafic.drawCircle(x, y, r);
    return stage.addChild(grafic);
  };

  dabcount = 0;

  newthing = function(x, y) {
    var pressure, r, timedelta, _ref;
    pressure = ((_ref = penAPI()) != null ? _ref.pressure : void 0) || 1;
    r = 2 + pressure * 10;
    timedelta = now();
    newstroke.push({
      x: x,
      y: y,
      r: r,
      t: timedelta
    });
    dabcount++;
    return prev = {
      x: x,
      y: y
    };
  };

  cacherender = function() {
    var bg, bgtex, newstage;
    console.log(renderer.view);
    bgtex = new PIXI.RenderTexture(WIDTH, HEIGHT);
    bgtex.render(stage);
    newstage = new PIXI.Stage(0xEEFFFF);
    bg = new PIXI.Sprite(bgtex);
    bg.position.x = 0;
    bg.position.y = 0;
    newstage.addChild(bg);
    return stage = newstage;
  };

  renderframe = function() {
    return renderer.render(stage);
  };

}).call(this);
