// Generated by CoffeeScript 1.6.3
(function() {
  var ABSMAXRADIUS, ABSMINRADIUS, ALTdrawhardlinewidth, CANVASHEIGHT, CANVASWIDTH, FUCK, Layer, NETWORKED, V2d, adjustalpha, alllayers, alphaslider, antialias, archivebutton, archiveurl, assembleimg, bindings, blueslider, body, bombbutton, bombsahoy, bresenham, brushpresets, brushselection, brushsizedelta, brushsizedown, brushsizeup, but, cache, cachebutton, cancel, cancelright, canvascircle, canvascontainer, canvaselem, canvasobj, chatbox, chatinput, chatname, clearcanvas, clearctx, clearlocalcache, clumps, color, colorbox, colorpicker, colorslider, colorwheel, colorwheeldom, contain, container, correctpos, csscolor, currentbrush, cursoroncanvas, dab, dataurl, degstorads, disablecanvas, displaycanvasctx, displaycanvaselem, draw, drawcursor, drawdab, drawellipse, drawhardcircle, drawhardfilledcircle, drawhardline, drawhardlinewidth, drawline, drawloop, drawpixel, drawstroke, enablecanvas, experimentaldrawstroke, exportjson, exportpng, exportsvg, flipbutton, flipped, fuckpickcolor, greenslider, handler, header, holdingright, htmlencode, imgd, info, infoprepend, intvector, isdrawing, k, keytapbind, label, lastdab, lastframe, layerlist, layers, listdata, ll, loadarchivedsession, loadchat, loadsession, log, makestroke, maxradius, midpointcircle, minradius, mpos, networkcursors, nocache, noop, olddrawstroke, oldexperimentaldrawstroke, opentoolbar, pausebutton, paused, pickcolor, prev, radiusslider, randdir, randvector, rdown, recentcolors, redslider, replaybutton, replaycontrols, replayspeed, replaytick, rfloat, rgba, round, savebutton, say, sign, skipbutton, skipreplay, socket, someonesaid, spuncolorwheel, startreplay, strokespertick, swatches, switchcolor, tabletaffectsopacity, tabletaffectsradius, tabletmodifier, tag, timebar, timecall, timelog, toggleflip, tolast, toolbar, updatecolor, updaterecentcolors, updateswatches, v, vadd, vdist, vmag, vndiv, vnmul, vnorm, vsub, wacom, zeropad,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  NETWORKED = true;

  CANVASWIDTH = 1200;

  CANVASHEIGHT = 600;

  ABSMINRADIUS = 1;

  ABSMAXRADIUS = 100;

  paused = false;

  currentbrush = 'default';

  Layer = (function() {
    function Layer() {
      var jqnew;
      this.visible = true;
      this.strokes = [];
      jqnew = $("<canvas>");
      jqnew.attr({
        width: CANVASWIDTH,
        height: CANVASHEIGHT
      });
      jqnew.css({
        border: '1px solid black'
      });
      this.canvas = jqnew[0];
    }

    return Layer;

  })();

  alllayers = [new Layer(), new Layer(), new Layer()];

  canvaselem = false;

  canvasobj = false;

  layers = {};

  layers.current = 0;

  layers.change = function(layernumber) {
    var lay;
    alllayers.forEach(function(layer) {
      return $(layer.canvas).removeClass('selectedlayer');
    });
    layers.current = layernumber;
    console.log(layernumber);
    lay = alllayers[layernumber];
    canvaselem = $(lay.canvas);
    canvaselem.addClass('selectedlayer');
    return canvasobj = lay.canvas.getContext("2d");
  };

  layers.change(0);

  contain = $("<div>");

  contain.resizable({
    handles: 's'
  });

  canvascontainer = $("<div id=canvascontainer>");

  contain.css({
    resize: 'vertical',
    'border-bottom': '2px solid gray',
    'padding-bottom': 1
  });

  contain.height(500);

  canvascontainer.css({
    overflow: 'auto',
    'min-height': 200
  });

  canvascontainer.css({
    height: '100%'
  });

  body = $("body");

  displaycanvaselem = $("<canvas id=doodlecanvas>");

  body.append(contain);

  contain.append(canvascontainer);

  displaycanvaselem.attr({
    height: CANVASHEIGHT
  });

  canvaselem.attr({
    height: CANVASHEIGHT
  });

  displaycanvaselem.attr({
    width: CANVASWIDTH
  });

  canvaselem.attr({
    width: CANVASWIDTH
  });

  displaycanvasctx = displaycanvaselem[0].getContext("2d");

  displaycanvasctx.fillStyle = 'white';

  displaycanvasctx.fillRect(0, 0, CANVASWIDTH, CANVASHEIGHT);

  canvascontainer.append(displaycanvaselem);

  tag = function(type, body) {
    if (type == null) {
      type = "div";
    }
    if (body == null) {
      body = "";
    }
    return "<" + type + ">" + body + "</" + type + ">";
  };

  dataurl = function(data) {
    return "data:image/svg+xml;base64," + btoa(data);
  };

  wacom = function() {
    return document.getElementById('wtPlugin');
  };

  tabletaffectsradius = false;

  tabletaffectsopacity = false;

  antialias = true;

  isdrawing = false;

  holdingright = false;

  nocache = false;

  cache = [];

  V2d = function(x, y) {
    return {
      x: x,
      y: y
    };
  };

  mpos = V2d(0, 0);

  rgba = function(r, g, b, a) {
    return {
      r: r,
      g: g,
      b: b,
      a: a
    };
  };

  adjustalpha = function(col, alpha) {
    return rgba(col.r, col.g, col.b, alpha);
  };

  recentcolors = [rgba(0, 0, 0, 1), rgba(255, 255, 255, 1), rgba(255, 0, 0, 1), rgba(255, 130, 110, 1)];

  socket = void 0;

  displaycanvaselem.mousedown(function(e) {
    if (e.button === 0) {
      mpos = correctpos(e);
      isdrawing = true;
    }
    if (e.button === 2) {
      holdingright = true;
      rdown(e);
    }
    return draw(mpos);
  });

  cancel = function(e) {
    if (e.button === 0) {
      isdrawing = false;
    }
    if (e.button === 2) {
      return holdingright = false;
    }
  };

  canvaselem.mouseup(cancel);

  body.mouseup(cancel);

  correctpos = function(e) {
    var offset, screenpageoffset, x, y;
    screenpageoffset = V2d(e.screenX - e.pageX, e.screenY - e.pageY);
    x = e.pageX;
    y = e.pageY;
    offset = displaycanvaselem.offset();
    x -= offset.left;
    y -= offset.top;
    if (flipped) {
      x = displaycanvaselem.width() - x;
    }
    return V2d(x, y);
  };

  color = rgba(0, 0, 0, 1);

  displaycanvaselem.bind('contextmenu', function(e) {
    return false;
  });

  imgd = canvasobj.getImageData(0, 0, CANVASWIDTH, CANVASHEIGHT);

  fuckpickcolor = function(ctx, pos) {
    var b, g, i, r;
    i = pos.x + CANVASWIDTH * pos.y;
    i *= 4;
    console.log(i);
    r = imgd.data[i + 0];
    g = imgd.data[i + 1];
    b = imgd.data[i + 2];
    return rgba(r, g, b, 1);
  };

  pickcolor = function(ctx, pos) {
    var b, g, r;
    imgd = displaycanvasctx.getImageData(pos.x, pos.y, 1, 1);
    r = imgd.data[0];
    g = imgd.data[1];
    b = imgd.data[2];
    return rgba(r, g, b, 1);
  };

  rdown = function(e) {
    var coleur;
    mpos = correctpos(e);
    coleur = pickcolor(canvasobj, mpos);
    coleur = adjustalpha(coleur, color.a);
    return updatecolor(coleur);
  };

  prev = void 0;

  minradius = 1;

  maxradius = 10;

  lastdab = void 0;

  vnmul = function(v, n) {
    return V2d(v.x * n, v.y * n);
  };

  vadd = function(a, b) {
    return V2d(a.x + b.x, a.y + b.y);
  };

  vsub = function(a, b) {
    return V2d(a.x - b.x, a.y - b.y);
  };

  vmag = function(v) {
    return Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2));
  };

  vdist = function(a, b) {
    return vmag(vsub(a, b));
  };

  cancelright = function(e) {
    if (e.button === 2) {
      return holdingright = false;
    }
  };

  displaycanvaselem.mouseup(cancelright);

  updaterecentcolors = function() {
    var i;
    if (__indexOf.call(recentcolors, color) >= 0) {
      i = recentcolors.indexOf(color);
      recentcolors.splice(i, 1);
      recentcolors.unshift(color);
      updateswatches();
    }
    if (__indexOf.call(recentcolors, color) < 0) {
      recentcolors.unshift(color);
      updateswatches();
    }
    if (recentcolors.length > 8) {
      recentcolors.pop();
      return updateswatches();
    }
  };

  switchcolor = function() {
    updatecolor(recentcolors[1]);
    return updaterecentcolors();
  };

  bindings = {};

  keytapbind = function(key, func) {
    var k;
    k = key.toUpperCase().charCodeAt(0);
    bindings[k] = func;
    return body.append("<a accesskey=" + key + "></a>");
  };

  keytapbind('x', switchcolor);

  $(document).bind('keydown', function(e) {
    var key;
    if (!e.altKey) {
      return;
    }
    key = e.which;
    if (bindings.hasOwnProperty(key)) {
      return bindings[key]();
    }
  });

  tabletmodifier = function(st) {
    var adjustedopacitypressure, adjustedradiuspressure, c, f, newalpha, newst, penapi, pressure, radiusrange, t, w;
    penapi = wacom().penAPI;
    pressure = penapi.pressure;
    adjustedradiuspressure = Math.pow(pressure, 2);
    adjustedopacitypressure = Math.pow(pressure, 3);
    c = st.color;
    if (penapi.isEraser) {
      c = rgba(255, 255, 255, 1);
      pressure = 1;
    }
    w = st.width;
    f = st.from;
    t = st.to;
    radiusrange = maxradius - minradius;
    if (tabletaffectsradius) {
      w = minradius + radiusrange * adjustedradiuspressure;
    }
    if (tabletaffectsopacity) {
      newalpha = c.a * adjustedopacitypressure;
      c = adjustalpha(c, newalpha);
    }
    newst = $.extend({}, st, {
      from: f,
      to: t,
      width: w,
      color: c,
      brush: st.brush
    });
    if (penapi.isEraser) {
      newst.brush = 'eraser';
    }
    return newst;
  };

  draw = function(mpos) {
    var penapi, st;
    if ((!isdrawing) || displaycanvaselem.hasClass("disabled")) {
      prev = void 0;
      lastdab = void 0;
      return;
    }
    penapi = wacom().penAPI;
    if (!prev) {
      prev = mpos;
    }
    if (prev) {
      st = {
        from: prev,
        to: mpos,
        width: maxradius,
        color: color,
        brush: currentbrush,
        layer: layers.current
      };
      if (penapi) {
        st = tabletmodifier(st);
      }
      makestroke(st);
    }
    return prev = V2d(mpos.x, mpos.y);
  };

  displaycanvaselem.mousedown(function(e) {
    return updaterecentcolors();
  });

  displaycanvaselem.mousemove(function(e) {
    if (holdingright) {
      return rdown(e);
    }
  });

  body.mousemove(function(e) {
    mpos = correctpos(e);
    return draw(mpos);
  });

  csscolor = function(col) {
    return "rgba(" + col.r + "," + col.g + "," + col.b + "," + col.a + ")";
  };

  olddrawstroke = function(st) {
    var tmpto;
    tmpto = st.to;
    if (st.from.x === st.to.x && st.from.y === st.to.y) {
      tmpto = vadd(st.to, V2d(0, 0.001));
    }
    canvasobj.strokeStyle = csscolor(st.color);
    canvasobj.lineWidth = st.width;
    canvasobj.lineCap = "round";
    canvasobj.beginPath();
    canvasobj.moveTo(st.from.x, st.from.y);
    canvasobj.lineTo(tmpto.x, tmpto.y);
    return canvasobj.stroke();
  };

  clumps = function(arr, n) {
    var i, x, _i, _len, _ref, _results;
    _ref = arr.slice(0, +(arr.length - n) + 1 || 9e9);
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      x = _ref[i];
      _results.push(arr.slice(i, i + n));
    }
    return _results;
  };

  canvascircle = function(context, pos, r) {
    context.beginPath();
    return context.arc(pos.x, pos.y, r, 0, 2 * Math.PI, false);
  };

  degstorads = function(deg) {
    return (deg * Math.PI) / 180;
  };

  drawellipse = function(ctx, pos, radius, rot, ratio) {
    ctx.save();
    ctx.translate(pos.x, pos.y);
    ctx.rotate(rot);
    ctx.scale(ratio, 1);
    canvascircle(ctx, V2d(0, 0), radius);
    ctx.fill();
    return ctx.restore();
  };

  vmag = function(v) {
    return Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2));
  };

  vndiv = function(v, n) {
    return V2d(v.x / n, v.y / n);
  };

  vnorm = function(v) {
    return vndiv(v, vmag(v));
  };

  rfloat = function() {
    return -1 + Math.random() * 2;
  };

  randdir = function() {
    return vnorm(V2d(rfloat(), rfloat()));
  };

  randvector = function() {
    return vnmul(randdir(), Math.random());
  };

  brushpresets = {};

  brushpresets["default"] = {
    adjust: function(st, pos, angle) {
      var ellipseratio, jitter;
      jitter = 0;
      pos = vadd(pos, vnmul(randvector(), jitter * st.width));
      ellipseratio = 1;
      return {
        pos: pos,
        radius: st.width / 2,
        angle: angle,
        ellipseratio: ellipseratio,
        color: st.color
      };
    }
  };

  brushpresets.eraser = {
    adjust: function(st, pos, angle) {
      var ellipseratio;
      color = rgba(0, 0, 0, 1);
      ellipseratio = 1;
      return {
        pos: pos,
        radius: st.width / 2,
        angle: angle,
        ellipseratio: ellipseratio,
        color: color,
        erase: true
      };
    }
  };

  brushpresets.chalk = {
    adjust: function(st, pos, angle) {
      var ellipseratio, jitter, radius;
      jitter = 1 / 8;
      radius = st.width / 8;
      pos = vadd(pos, vnmul(randvector(), jitter * st.width));
      ellipseratio = 1;
      return {
        pos: pos,
        radius: radius,
        angle: angle,
        ellipseratio: ellipseratio,
        color: st.color
      };
    }
  };

  brushpresets.spatter = {
    adjust: function(st, pos, angle) {
      var ellipseratio, jitter, radius, tmpcolor;
      jitter = 1;
      radius = st.width * Math.random() / 10;
      tmpcolor = st.color;
      pos = vadd(pos, vnmul(randvector(), jitter * st.width));
      ellipseratio = 1;
      return {
        pos: pos,
        radius: radius,
        angle: angle,
        ellipseratio: ellipseratio,
        color: tmpcolor
      };
    }
  };

  brushpresets.noise = {
    adjust: function(st, pos, angle) {
      var ellipseratio, jitter, radius, tmpcolor;
      jitter = 1;
      radius = st.width * Math.random() / 10;
      tmpcolor = pickcolor(canvasobj, pos);
      tmpcolor = adjustalpha(tmpcolor, 1);
      pos = vadd(pos, vnmul(randvector(), jitter * st.width));
      ellipseratio = 1;
      return {
        pos: pos,
        radius: radius,
        angle: angle,
        ellipseratio: ellipseratio,
        color: tmpcolor
      };
    }
  };

  brushpresets.smudge = {
    adjust: function(st, pos, angle) {
      var ellipseratio, jitter, tmpcolor;
      jitter = 0;
      tmpcolor = pickcolor(canvasobj, pos);
      tmpcolor = adjustalpha(tmpcolor, 0.1);
      pos = vadd(pos, vnmul(randvector(), jitter * st.width));
      ellipseratio = 1;
      return {
        pos: pos,
        radius: st.width / 2,
        angle: angle,
        ellipseratio: ellipseratio,
        color: tmpcolor
      };
    }
  };

  brushpresets.wetpaint = {
    adjust: function(st, pos, angle) {
      var ellipseratio, jitter, tmpcolor;
      jitter = 0;
      tmpcolor = pickcolor(canvasobj, pos);
      tmpcolor = adjustalpha(tmpcolor, 0.5);
      pos = vadd(pos, vnmul(randvector(), jitter * st.width));
      ellipseratio = 0.4;
      return {
        pos: pos,
        radius: st.width / 2,
        angle: angle,
        ellipseratio: ellipseratio,
        color: tmpcolor
      };
    }
  };

  brushpresets.bristles = {
    adjust: function(st, pos, angle) {
      var ellipseratio, jitter, radius, speed, tmpcolor;
      speed = vmag(vsub(st.to, st.from));
      jitter = 1 / 2;
      tmpcolor = st.color;
      pos = vadd(pos, vnmul(randvector(), jitter * st.width));
      ellipseratio = 0.1;
      radius = st.width * 2 / 3;
      angle += Math.PI / 2;
      return {
        pos: pos,
        radius: radius,
        angle: angle,
        ellipseratio: ellipseratio,
        color: tmpcolor
      };
    }
  };

  experimentaldrawstroke = function(st) {
    var FRAC, brush, dabcount, dabz, dir, radiusperdab, strokediff, strokedirection, threshold, _i, _results;
    layers.change(st.layer || 0);
    radiusperdab = 1 / 20;
    threshold = st.width * radiusperdab;
    FRAC = vdist(st.from, st.to) / st.width;
    dabcount = Math.ceil(vdist(st.from, st.to) / threshold);
    dabcount = Math.max(2, dabcount);
    Math.seedrandom(st.brush + String(st.to.x) + String(st.to.y) + String(st.from.x) + String(st.from.y) + String(dabcount));
    dir = vsub(st.to, st.from);
    dabz = (function() {
      _results = [];
      for (var _i = 0; 0 <= dabcount ? _i <= dabcount : _i >= dabcount; 0 <= dabcount ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(function(n) {
      var c, offs;
      c = n / dabcount;
      offs = vnmul(dir, c);
      return vadd(st.from, offs);
    });
    strokediff = vsub(st.from, st.to);
    strokedirection = Math.atan2(strokediff.y, strokediff.x);
    brush = brushpresets[st.brush] || brushpresets["default"];
    dabz.forEach(function(dab) {
      var newdab;
      newdab = brush.adjust(st, dab, strokedirection);
      canvasobj.fillStyle = csscolor(newdab.color);
      if (newdab.erase) {
        canvasobj.globalCompositeOperation = 'destination-out';
      }
      drawellipse(canvasobj, newdab.pos, newdab.radius, newdab.angle, newdab.ellipseratio);
      return canvasobj.globalCompositeOperation = 'source-over';
    });
    return canvasobj.globalCompositeOperation = 'source-over';
  };

  oldexperimentaldrawstroke = function(st) {
    var FRAC, alphafrac, cd, clumpdab, dabcount, dabz, dir, radiusperdab, threshold, tmpcol, tmpst, _i, _j, _len, _results, _results1;
    alphafrac = 1 / 2;
    radiusperdab = 1 / 20;
    threshold = st.width * radiusperdab;
    FRAC = vdist(st.from, st.to) / st.width;
    dabcount = Math.ceil(vdist(st.from, st.to) / threshold);
    dabcount = Math.max(2, dabcount);
    dir = vsub(st.to, st.from);
    dabz = (function() {
      _results = [];
      for (var _i = 0; 0 <= dabcount ? _i <= dabcount : _i >= dabcount; 0 <= dabcount ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(function(n) {
      var c, offs;
      c = n / dabcount;
      offs = vnmul(dir, c);
      return vadd(st.from, offs);
    });
    clumpdab = clumps(dabz, 2);
    tmpcol = adjustalpha(st.color, st.color.a * alphafrac);
    _results1 = [];
    for (_j = 0, _len = clumpdab.length; _j < _len; _j++) {
      cd = clumpdab[_j];
      tmpst = {
        from: cd[0],
        to: cd[1],
        color: tmpcol,
        width: st.width
      };
      _results1.push(drawline(canvasobj, tmpst));
    }
    return _results1;
  };

  drawline = function(canvasobj, st) {
    canvasobj.strokeStyle = csscolor(st.color);
    canvasobj.lineWidth = st.width;
    canvasobj.lineCap = "round";
    canvasobj.beginPath();
    canvasobj.moveTo(st.from.x, st.from.y);
    canvasobj.lineTo(st.to.x, st.to.y);
    return canvasobj.stroke();
  };

  drawdab = function(st) {};

  drawstroke = function(st) {
    if (antialias) {
      return experimentaldrawstroke(st);
    } else {
      return drawhardlinewidth(canvasobj, st.from, st.to, st.color, st.width / 2);
    }
  };

  noop = function() {};

  handler = function(data, jblerf) {};

  makestroke = function(st) {
    var col, from, r, strokedata, to;
    from = st.from;
    to = st.to;
    r = st.width;
    col = st.color;
    strokedata = st;
    cache.push(strokedata);
    replaytick();
    if (socket) {
      return socket.emit('stroke', strokedata);
    }
  };

  dab = function(pos, r, col) {
    var dabdata;
    dabdata = {
      c: col,
      p: pos,
      r: r
    };
    cache.push(dabdata);
    replaytick();
    if (socket) {
      return socket.emit('stroke', dabdata);
    }
  };

  drawdab = function(pos, r, col) {
    canvasobj.beginPath();
    canvasobj.arc(pos.x, pos.y, r, 0, 2 * Math.PI, true);
    canvasobj.fillStyle = csscolor(col);
    return canvasobj.fill();
  };

  toolbar = $("<div id=toolbar>");

  toolbar.css({
    position: 'relative',
    overflow: 'auto',
    height: '100%'
  });

  contain.append(toolbar);

  header = function(str) {
    return $(tag("h3", str));
  };

  label = function(str) {
    return $(tag("label", str));
  };

  toolbar.append(header("brush"));

  toolbar.append(container = $("<div>"));

  container.append(brushselection = $("<select>"));

  for (k in brushpresets) {
    v = brushpresets[k];
    brushselection.append(tag("option", k));
  }

  brushselection.change(function(e) {
    return currentbrush = this.value;
  });

  container.append(label("size"));

  radiusslider = $("<div></div>");

  radiusslider.slider({
    min: ABSMINRADIUS,
    max: ABSMAXRADIUS,
    range: true,
    slide: function(e, ui) {
      minradius = ui.values[0];
      return maxradius = ui.values[1];
    }
  });

  container.append(radiusslider);

  brushsizedelta = function(delta) {
    maxradius = maxradius + delta;
    maxradius = Math.max(maxradius, ABSMINRADIUS);
    maxradius = Math.min(maxradius, ABSMAXRADIUS);
    return radiusslider.slider('values', minradius, maxradius);
  };

  brushsizeup = function() {
    return brushsizedelta(1);
  };

  brushsizedown = function() {
    return brushsizedelta(-1);
  };

  keytapbind('z', brushsizedown);

  keytapbind('a', brushsizeup);

  toolbar.append(header("color"));

  toolbar.append(colorpicker = $("<div>"));

  colorpicker.addClass('colorpicker');

  colorslider = function() {
    var sliderelem;
    sliderelem = $("<div>");
    sliderelem.slider({
      min: 1,
      max: 255,
      range: 'min'
    });
    sliderelem.css({
      height: 50,
      display: 'inline-block'
    });
    return sliderelem;
  };

  redslider = colorslider().slider({
    orientation: 'vertical',
    slide: function(e, ui) {
      return updatecolor(rgba(ui.value, color.g, color.b, color.a));
    }
  });

  greenslider = colorslider().slider({
    orientation: 'vertical',
    slide: function(e, ui) {
      return updatecolor(rgba(color.r, ui.value, color.b, color.a));
    }
  });

  blueslider = colorslider().slider({
    orientation: 'vertical',
    slide: function(e, ui) {
      return updatecolor(rgba(color.r, color.g, ui.value, color.a));
    }
  });

  redslider.addClass('red');

  greenslider.addClass('green');

  blueslider.addClass('blue');

  alphaslider = $("<div>");

  alphaslider.slider({
    min: 0,
    max: 1,
    step: 0.01,
    value: 1,
    slide: function(e, ui) {
      return updatecolor(rgba(color.r, color.g, color.b, ui.value));
    }
  });

  colorbox = $("<div>&nbsp;</div>");

  colorpicker.append(colorbox);

  colorbox.css({
    height: 32,
    width: 32,
    float: 'right'
  });

  colorpicker.append(redslider, greenslider, blueslider, alphaslider);

  colorpicker.append(colorwheeldom = $("<div>"));

  colorwheel = Raphael.colorwheel(colorwheeldom, 128);

  updatecolor = function(col) {
    color = col;
    redslider.slider({
      value: color.r
    });
    greenslider.slider({
      value: color.g
    });
    blueslider.slider({
      value: color.b
    });
    alphaslider.slider({
      value: color.a
    });
    colorbox.css("background", csscolor(color));
    return colorwheel.color(csscolor(color));
  };

  spuncolorwheel = function(col) {
    color = col;
    redslider.slider({
      value: color.r
    });
    greenslider.slider({
      value: color.g
    });
    blueslider.slider({
      value: color.b
    });
    alphaslider.slider({
      value: color.a
    });
    return colorbox.css("background", csscolor(color));
  };

  round = Math.round;

  noop = function() {};

  colorwheel.onchange(function(rcol) {
    var nc;
    nc = rgba(round(rcol.r), round(rcol.g), round(rcol.b), color.a);
    return spuncolorwheel(nc);
  });

  swatches = $("<div></div>");

  colorpicker.append(swatches);

  updateswatches = function() {
    var x;
    x = recentcolors.map(function(col) {
      var but;
      but = $(tag("button"));
      but.css({
        "background": csscolor(col)
      });
      but.button();
      but.css({
        width: 20,
        height: 20
      });
      return but.click(function() {
        return updatecolor(col);
      });
    });
    swatches.html('');
    return swatches.append(x);
  };

  clearctx = function(ctx) {
    return ctx.clearRect(0, 0, CANVASWIDTH, CANVASHEIGHT);
  };

  clearcanvas = function() {
    return alllayers.forEach(function(layer) {
      return clearctx(layer.canvas.getContext('2d'));
    });
  };

  lastframe = 0;

  startreplay = function() {
    clearcanvas();
    lastframe = 0;
    return false;
  };

  strokespertick = 1;

  disablecanvas = function() {
    return displaycanvaselem.addClass("disabled");
  };

  enablecanvas = function() {
    return displaycanvaselem.removeClass("disabled");
  };

  timecall = function(func) {
    var starttime;
    starttime = Date.now();
    func();
    return Date.now() - starttime;
  };

  replaytick = function() {
    var curr, x, _i;
    if (lastframe === 0 && cache.length > 3) {
      disablecanvas();
    }
    if (lastframe === cache.length) {
      if (nocache && cache.length > 100) {
        clearlocalcache();
      }
      enablecanvas();
    }
    if (cache.length > lastframe) {
      for (x = _i = 0; 0 <= strokespertick ? _i <= strokespertick : _i >= strokespertick; x = 0 <= strokespertick ? ++_i : --_i) {
        if (cache.length > lastframe) {
          curr = cache[lastframe];
          drawstroke(curr);
          lastframe++;
        }
      }
    }
    return timebar.progressbar({
      value: lastframe,
      max: cache.length
    });
  };

  cursoroncanvas = false;

  displaycanvaselem.mouseenter(function() {
    return cursoroncanvas = true;
  });

  displaycanvaselem.mouseout(function() {
    return cursoroncanvas = false;
  });

  networkcursors = [];

  assembleimg = function() {
    displaycanvasctx.fillstyle = 'white';
    displaycanvasctx.fillRect(0, 0, CANVASWIDTH, CANVASHEIGHT);
    return alllayers.forEach(function(layer) {
      if (layer.visible) {
        return displaycanvasctx.drawImage(layer.canvas, 0, 0);
      }
    });
  };

  drawloop = function() {
    var times;
    if (!paused) {
      times = timecall(function() {
        return replaytick(lastframe);
      });
    }
    assembleimg();
    setTimeout(drawloop, times);
    if (cursoroncanvas) {
      drawcursor(mpos, color, maxradius);
      drawcursor(mpos, color, minradius);
    }
    networkcursors.forEach(function(c) {
      return c();
    });
    return networkcursors = [];
  };

  drawcursor = function(pos, col, rad) {
    var dcc;
    dcc = displaycanvasctx;
    dcc.beginPath();
    dcc.arc(pos.x, pos.y, rad / 2, 0, 2 * Math.PI, false);
    dcc.lineWidth = 1;
    dcc.fillStyle = 'none';
    dcc.strokeStyle = csscolor(adjustalpha(col, 1 / 2));
    return dcc.stroke();
  };

  skipreplay = function() {
    tolast();
    return false;
  };

  keytapbind('k', skipreplay);

  tolast = function() {
    var _results;
    _results = [];
    while (cache.length > lastframe) {
      _results.push(replaytick());
    }
    return _results;
  };

  skipbutton = $("<button>\"skip\" replay (may cause a huge delay)</button>");

  skipbutton.click(skipreplay);

  skipbutton.button();

  archiveurl = "./files/archive/20130904.json.txt";

  loadarchivedsession = function(url) {
    log("downloading session...");
    return $.get(url, (function(data, textstatus, jqxhr) {
      var fcount;
      cache = data;
      fcount = cache.length;
      log("cache loaded, " + fcount + " strokes.");
      return startreplay();
    }), 'json');
  };

  archivebutton = $("<button>view an archived session</button>");

  archivebutton.click(function() {
    alert("keep in mind this just affects your local replay, any new doodling that happens wll be sent to the current active session \n  TODO: fix this");
    return loadarchivedsession(archiveurl);
  });

  archivebutton.button();

  replayspeed = $("<div>");

  replayspeed.css({
    'width': 100
  });

  replayspeed.slider({
    min: 1,
    max: 200,
    slide: (function(e, ui) {
      return strokespertick = ui.value;
    })
  });

  loadsession = function() {
    log("downloading session...");
    return $.get('/getsession', (function(data, textstatus, jqxhr) {
      var fcount;
      cache = data;
      fcount = cache.length;
      log("cache loaded, " + fcount + " strokes.");
      return startreplay();
    }), 'json');
  };

  toolbar.append(header("tablet (wacom driver)"));

  toolbar.append(container = $("<div>"));

  container.append(label("pressure affects..."));

  container.append($("<input type=checkbox id=pressure /><label for=pressure>size</label>"));

  container.append($("<input type=checkbox id=opacity /><label for=opacity>opacity</label>"));

  $('#pressure').change(function() {
    return tabletaffectsradius = this.checked;
  });

  $('#opacity').change(function() {
    return tabletaffectsopacity = this.checked;
  });

  toolbar.append(header("misc"));

  toolbar.append(container = $("<div>"));

  container.append(label("export "));

  exportpng = function() {
    var url;
    assembleimg();
    url = displaycanvaselem.get(0).toDataURL("image/png");
    return window.open(url);
  };

  keytapbind('p', exportpng);

  keytapbind('r', startreplay);

  savebutton = $(tag("button", ".png"));

  savebutton.click(function() {
    return exportpng();
  });

  savebutton.button();

  container.append(savebutton);

  exportsvg = function() {
    var data;
    data = "";
    data += "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewbox='0 0 1000 600'>";
    data += cache.map(function(s) {
      return "<line x1='" + s.from.x + "' y1='" + s.from.y + "' x2='" + s.to.x + "' y2='" + s.to.y + "' stroke='" + (csscolor(s.color)) + "' stroke-width='" + s.width + "' stroke-linecap='round' />";
    }).join();
    data += "</svg>";
    window.open(dataurl(data));
    return false;
  };

  savebutton = $(tag("button", ".svg"));

  savebutton.click(function() {
    return exportsvg();
  });

  savebutton.button();

  container.append(savebutton);

  exportjson = function() {
    return window.open("/getsession");
  };

  savebutton = $(tag("button", ".json"));

  savebutton.click(function() {
    return exportjson();
  });

  savebutton.button();

  container.append(savebutton);

  flipped = false;

  toggleflip = function() {
    flipped = !flipped;
    if (flipped) {
      return displaycanvaselem.addClass('flipped');
    } else {
      return displaycanvaselem.removeClass('flipped');
    }
  };

  flipbutton = $(tag("button", "flip canvas view"));

  flipbutton.click(toggleflip);

  flipbutton.button();

  container.append(flipbutton);

  container.append(layerlist = $("<div>"));

  layerlist.append($(tag('h3', 'layers')));

  alllayers.forEach(function(layer, index) {
    var but;
    layerlist.append(but = $(tag("button", "toggle")));
    but.click(function() {
      return layer.visible = !layer.visible;
    });
    layerlist.append(layer.canvas);
    $(layer.canvas).css({
      'max-width': 100
    });
    return $(layer.canvas).click(function() {
      return layers.change(index);
    });
  });

  keytapbind('i', toggleflip);

  bombsahoy = function() {
    cache = [];
    startreplay();
    return log("BOMBS AHOY");
  };

  bombbutton = $(tag("button", "BOMB"));

  bombbutton.click(function() {
    if (!(confirm('really?') && confirm("are you super sure? this will nuke the contents of the canvas straight off the face of the earth"))) {
      return false;
    }
    bombsahoy();
    socket.emit('bomb');
    return false;
  });

  bombbutton.button();

  bombbutton.css({
    'font-size': 10,
    'margin-top': 20,
    color: 'darkred',
    display: 'block'
  });

  container.append(bombbutton);

  container.append(ll = label("big friendly global thermonuclear annihilation button, pressing it will destroy the canvas contents"));

  ll.css({
    color: 'gray'
  });

  $.fn.togglepanels = function() {
    return this.each(function() {
      return $(this).addClass("ui-accordion ui-accordion-icons ui-widget ui-helper-reset").find("h3").addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-top ui-corner-bottom").hover(function() {
        return $(this).toggleClass("ui-state-hover");
      }).prepend('<span class="ui-icon ui-icon-triangle-1-e"></span>').click(function() {
        $(this).toggleClass("ui-accordion-header-active ui-state-active ui-state-default ui-corner-bottom").find("> .ui-icon").toggleClass("ui-icon-triangle-1-e ui-icon-triangle-1-s").end().next().slideToggle();
        return false;
      }).next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom").hide();
    });
  };

  toolbar.css({
    'float': 'left',
    width: '150px'
  });

  toolbar.insertBefore(canvascontainer);

  opentoolbar = function() {
    return toolbar.dialog('open');
  };

  replaycontrols = $("<div id=replaycontrols>");

  replaycontrols.css({
    clear: 'left'
  });

  body.append(replaycontrols);

  pausebutton = $("<button>pause/unpause replay</button>");

  pausebutton.button();

  pausebutton.click(function() {
    return paused = !paused;
  });

  replaybutton = $("<button>restart replay</button>");

  replaybutton.button();

  replaybutton.click(startreplay);

  replayspeed.css({
    'margin': 5,
    float: 'left'
  });

  timebar = $("<div></div>");

  replaycontrols.append("<label>replay speed</label>");

  replaycontrols.append(replayspeed);

  replaycontrols.append(skipbutton);

  cachebutton = $("<button>clear local replay cache</button>");

  clearlocalcache = function() {
    cache = [];
    return lastframe = 0;
  };

  cachebutton.click(clearlocalcache);

  cachebutton.button();

  replaycontrols.append(pausebutton, replaybutton);

  replaycontrols.append($("<input type=checkbox id=nocache /><label for=nocache>clear cache automagically</label>"));

  $('#nocache').change(function() {
    return nocache = this.checked;
  });

  replaycontrols.append("&middot;");

  replaycontrols.append($("<div id='hotkeyinfo'></div>"));

  listdata = ["i - flip canvas", "a/z - change brush size", "x - swap color", "p - png snapshot", "r - replay", "k - skip replay (takes a while)"].map(function(x) {
    return tag("li", x);
  });

  $("#hotkeyinfo").append("Hold alt and press one of the following:\n" + tag("ul", listdata.join("")));

  $("#hotkeyinfo").hide();

  replaycontrols.append(but = $("<button>hotkey info</button>"));

  but.button();

  but.click(function() {
    return $("#hotkeyinfo").dialog();
  });

  replaycontrols.append(timebar);

  info = $("<div>");

  info.css({
    width: '100%',
    background: 'white',
    font: 'sans-serif',
    overflow: 'scroll',
    height: '300px'
  });

  zeropad = function(num) {
    if (num < 10) {
      return '0' + num;
    }
    return String(num);
  };

  infoprepend = function(text) {
    var hh, mm, now, ss, timestamp;
    now = new Date;
    hh = zeropad(now.getHours());
    mm = zeropad(now.getMinutes());
    ss = zeropad(now.getSeconds());
    timestamp = "" + hh + ":" + mm + ":" + ss;
    text = timestamp + "|&nbsp;" + text;
    return info.prepend(text);
  };

  timelog = function(time, text) {
    var hh, mm, ss, timestamp;
    hh = zeropad(time.getHours());
    mm = zeropad(time.getMinutes());
    ss = zeropad(time.getSeconds());
    timestamp = "" + hh + ":" + mm + ":" + ss;
    text = timestamp + "|&nbsp;" + text;
    return info.prepend(text);
  };

  htmlencode = function(str) {
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  };

  someonesaid = function(timems, name, text) {
    var time;
    time = new Date(timems);
    return timelog(time, "" + (htmlencode(name)) + "> " + (htmlencode(text)) + "<br/>\n");
  };

  chatname = false;

  say = function(text) {
    var time;
    if (!chatname) {
      chatname = prompt("pick a name", 'anon');
    }
    if (!chatname) {
      return;
    }
    text = chatinput.val();
    time = new Date().getTime();
    someonesaid(time, chatname, text);
    return socket.emit('say', {
      name: chatname,
      text: text,
      time: time
    });
  };

  chatbox = $("<form>");

  chatbox.css({
    margin: 0
  });

  chatbox.submit(function() {
    say(chatinput.val());
    chatinput.val('');
    return false;
  });

  body.append(chatbox);

  chatbox.append(chatinput = $("<input type='text' placeholder='type words here'>"));

  chatinput.css({
    'width': '100%'
  });

  chatinput;

  body.append(info);

  info.css({
    'user-select': 'text'
  });

  skipbutton.css({
    'float': 'right'
  });

  log = function(text) {
    return infoprepend("**" + text + "<br/>\n");
  };

  loadchat = function() {
    return $.get('/chatlog', (function(data, textstatus, jqxhr) {
      var datum, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        datum = data[_i];
        _results.push(someonesaid(datum.time, datum.name, datum.text));
      }
      return _results;
    }), 'json');
  };

  $(document).ready(function() {
    loadsession();
    loadchat();
    disablecanvas();
    drawloop();
    brushsizedelta(0);
    updateswatches();
    if (NETWORKED) {
      socket = io.connect('/');
      socket.on('stroke', function(data) {
        cache.push(data);
        return networkcursors.push(function() {
          return drawcursor(data.to, rgba(0, 0, 0, 1 / 2), data.width);
        });
      });
      socket.on('say', function(data) {
        return someonesaid(data.time, data.name, data.text);
      });
      return socket.on('bomb', function(data) {
        return bombsahoy();
      });
    }
  });

  drawpixel = function(ctx, x, y, col) {
    var size;
    ctx.fillStyle = csscolor(col);
    size = 1;
    return ctx.fillRect(x, y, size, size);
  };

  intvector = function(vec) {
    return {
      x: Math.round(vec.x),
      y: Math.round(vec.y)
    };
  };

  drawhardline = function(ctx, from, to, col) {
    var deltaerr, deltax, deltay, error, x, y, _i, _ref, _ref1, _results;
    deltax = to.x - from.x;
    deltay = to.y - from.y;
    error = 0;
    deltaerr = Math.abs(deltay / deltax);
    y = from.y;
    _results = [];
    for (x = _i = _ref = from.x, _ref1 = to.x; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; x = _ref <= _ref1 ? ++_i : --_i) {
      drawpixel(ctx, x, y, col);
      error = error + deltaerr;
      if (error > 0.5) {
        y = y + 1;
        _results.push(error = error - 1);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  bresenham = function(from, to, func) {
    var dx, dy, e2, err, loopiterations, sx, sy, x, y, _results;
    from = intvector(from);
    to = intvector(to);
    dx = Math.abs(to.x - from.x);
    dy = Math.abs(to.y - from.y);
    sx = from.x < to.x ? 1 : -1;
    sy = from.y < to.y ? 1 : -1;
    x = from.x;
    y = from.y;
    err = dx - dy;
    loopiterations = 0;
    _results = [];
    while (true) {
      loopiterations++;
      func(x, y);
      if (x === to.x && y === to.y) {
        break;
      }
      e2 = 2 * err;
      if (e2 > -dy) {
        err = err - dy;
        x += sx;
      }
      if (x === to.x && y === to.y) {
        func(x, y);
        break;
      }
      if (e2 < dx) {
        err = err + dx;
        _results.push(y += sy);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  drawhardline = function(ctx, from, to, col) {
    return bresenham(from, to, function(x, y) {
      return drawpixel(ctx, x, y, col);
    });
  };

  ALTdrawhardlinewidth = function(ctx, from, to, col, r) {
    return bresenham(from, to, function(x, y) {
      var pos;
      pos = V2d(x, y);
      return drawhardfilledcircle(ctx, pos, r, col);
    });
  };

  drawhardfilledcircle = function(ctx, pos, r, col) {
    var radiuserror, x, x0, y, y0, _results;
    r = Math.floor(r);
    x0 = Math.round(pos.x);
    y0 = Math.round(pos.y);
    x = r;
    y = 0;
    radiuserror = 1 - x;
    _results = [];
    while (x >= y) {
      drawhardline(ctx, V2d(x + x0, y + y0), V2d(-x + x0, y + y0), col);
      drawhardline(ctx, V2d(y + x0, x + y0), V2d(-y + x0, x + y0), col);
      drawhardline(ctx, V2d(-x + x0, -y + y0), V2d(x + x0, -y + y0), col);
      drawhardline(ctx, V2d(-y + x0, -x + y0), V2d(y + x0, -x + y0), col);
      y++;
      if (radiuserror < 0) {
        _results.push(radiuserror += 2 * y + 1);
      } else {
        x--;
        _results.push(radiuserror += 2 * (y - x + 1));
      }
    }
    return _results;
  };

  midpointcircle = function(pos, r, func) {
    var offs, rad, radiuserror, x, x0, y, y0, _results;
    if (Math.floor(r) < r) {
      offs = V2d(10, 0);
      rad = Math.floor(r);
      midpointcircle(vadd(pos, V2d(1, 0)), rad, func);
      midpointcircle(vadd(pos, V2d(0, 1)), rad, func);
      return;
    }
    x0 = Math.floor(pos.x);
    y0 = Math.floor(pos.y);
    x = r;
    y = 0;
    radiuserror = 1 - x;
    _results = [];
    while (x >= y) {
      func(x + x0, y + y0);
      func(y + x0, x + y0);
      func(-x + x0, y + y0);
      func(-y + x0, x + y0);
      func(-x + x0, -y + y0);
      func(-y + x0, -x + y0);
      func(x + x0, -y + y0);
      func(y + x0, -x + y0);
      y++;
      if (radiuserror < 0) {
        _results.push(radiuserror += 2 * y + 1);
      } else {
        x--;
        _results.push(radiuserror += 2 * (y - x + 1));
      }
    }
    return _results;
  };

  drawhardcircle = function(ctx, pos, r, col) {
    return midpointcircle(pos, r, function(x, y) {
      return drawpixel(ctx, x, y, col);
    });
  };

  sign = function(x) {
    if (x > 0) {
      return 1;
    }
    if (x < 0) {
      return -1;
    }
    return 0;
  };

  drawhardlinewidth = function(ctx, from, to, col, r) {
    var offs;
    r = r - 1;
    drawhardfilledcircle(ctx, from, r, col);
    offs = vsub(to, from);
    return midpointcircle(from, r, function(x, y) {
      var SHIT, f, t, xSHIT, ySHIT;
      f = V2d(x, y);
      t = vadd(f, offs);
      drawhardline(ctx, f, t, col);
      SHIT = vsub(from, f);
      xSHIT = V2d(sign(SHIT.x), 0);
      drawhardline(ctx, vadd(f, xSHIT), vadd(t, xSHIT), col);
      ySHIT = V2d(0, sign(SHIT.y));
      return drawhardline(ctx, vadd(f, ySHIT), vadd(t, ySHIT), col);
    });
  };

  FUCK = function() {
    var radiuserror, x, x0, y, y0, _results;
    x0 = Math.floor(pos.x);
    y0 = Math.floor(pos.y);
    x = r;
    y = 0;
    radiuserror = 1 - x;
    _results = [];
    while (x >= y) {
      drawpixel(ctx, x + x0, y + y0, col);
      drawpixel(ctx, y + x0, x + y0, col);
      drawpixel(ctx, -x + x0, y + y0, col);
      drawpixel(ctx, -y + x0, x + y0, col);
      drawpixel(ctx, -x + x0, -y + y0, col);
      drawpixel(ctx, -y + x0, -x + y0, col);
      drawpixel(ctx, x + x0, -y + y0, col);
      drawpixel(ctx, y + x0, -x + y0, col);
      y++;
      if (radiuserror < 0) {
        _results.push(radiuserror += 2 * y + 1);
      } else {
        x--;
        _results.push(radiuserror += 2 * (y - x + 1));
      }
    }
    return _results;
  };

  updatecolor(rgba(0, 0, 0, 1));

}).call(this);
