// Generated by CoffeeScript 1.6.3
(function() {
  var ABSMAXRADIUS, ABSMINRADIUS, CANVASHEIGHT, CANVASWIDTH, NETWORKED, V2d, adjustalpha, alphaslider, antialias, archivebutton, archiveurl, assembleimg, bindings, blueslider, body, bombbutton, bombsahoy, brushcanvas, brushpresets, brushselection, brushsizedelta, brushsizedown, brushsizeup, brushtexture, but, cache, cachebutton, cancel, cancelright, canvascontainer, canvasobj, chatbox, chatinput, chatname, clearcanvas, clearctx, clearlocalcache, clumps, color, colorbox, colorpicker, colorslider, colorwheel, colorwheeldom, contain, container, context, correctpos, csscolor, currentbrush, cursoroncanvas, dataurl, datelog, degstorads, disablecanvas, displaycanvasctx, displaycanvaselem, draw, drawcursor, drawloop, drawstroke, enablecanvas, exportjson, exportpng, exportsvg, flipbutton, flipped, greenslider, header, holdingright, htmlencode, info, infoprepend, isdrawing, jqbrush, k, keytapbind, lab, label, lastdab, lastframe, listdata, ll, loadarchivedsession, loadchat, loadsession, log, luup, makestroke, maxradius, minradius, mpos, networkcursors, nocache, opentoolbar, pausebutton, paused, pickcolor, pixicolor, prev, prevtime, rad, radiusslider, randdir, randvector, rdown, recentcolors, redslider, renderer, replaybutton, replaycontrols, replayspeed, replaytick, rfloat, rgba, rgbpicker, round, savebutton, say, skipbutton, skipreplay, socket, someonesaid, spuncolorwheel, stage, stagecount, startreplay, strokespertick, swatches, switchcolor, tabletaffectsopacity, tabletaffectsradius, tabletmodifier, tag, tickbutton, timebar, timecall, timelog, toggleflip, tolast, toolbar, transparent, updatecolor, updaterecentcolors, updateswatches, v, vadd, vdist, vmag, vndiv, vnmul, vnorm, vsub, wacom, weekdays, zeropad,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  NETWORKED = true;

  CANVASWIDTH = 1200;

  CANVASHEIGHT = 600;

  ABSMINRADIUS = 1;

  ABSMAXRADIUS = 100;

  paused = false;

  currentbrush = 'default';

  canvasobj = false;

  contain = $("<div>");

  contain.resizable({
    handles: 's'
  });

  canvascontainer = $("<div id=canvascontainer>");

  contain.css({
    resize: 'vertical',
    'border-bottom': '2px solid gray',
    'padding-bottom': 1
  });

  contain.height(500);

  canvascontainer.css({
    overflow: 'auto',
    'min-height': 200
  });

  canvascontainer.css({
    height: '100%'
  });

  body = $("body");

  displaycanvaselem = $("<canvas id=doodlecanvas>");

  body.append(contain);

  contain.append(canvascontainer);

  displaycanvaselem.attr({
    height: CANVASHEIGHT
  });

  displaycanvaselem.attr({
    width: CANVASWIDTH
  });

  displaycanvasctx = displaycanvaselem[0].getContext("2d");

  displaycanvasctx.fillStyle = 'white';

  displaycanvasctx.fillRect(0, 0, CANVASWIDTH, CANVASHEIGHT);

  canvascontainer.append(displaycanvaselem);

  tag = function(type, body) {
    if (type == null) {
      type = "div";
    }
    if (body == null) {
      body = "";
    }
    return "<" + type + ">" + body + "</" + type + ">";
  };

  dataurl = function(data) {
    return "data:image/svg+xml;base64," + btoa(data);
  };

  wacom = function() {
    return document.getElementById('wtPlugin');
  };

  tabletaffectsradius = false;

  tabletaffectsopacity = false;

  isdrawing = false;

  holdingright = false;

  nocache = false;

  cache = [];

  V2d = function(x, y) {
    return {
      x: x,
      y: y
    };
  };

  mpos = V2d(0, 0);

  rgba = function(r, g, b, a) {
    return {
      r: r,
      g: g,
      b: b,
      a: a
    };
  };

  adjustalpha = function(col, alpha) {
    return rgba(col.r, col.g, col.b, alpha);
  };

  recentcolors = [rgba(0, 0, 0, 1), rgba(255, 255, 255, 1), rgba(255, 0, 0, 1), rgba(255, 130, 110, 1)];

  socket = void 0;

  stage = new PIXI.Stage(0xFFFFFF, true);

  transparent = true;

  antialias = true;

  renderer = new PIXI.autoDetectRenderer(CANVASWIDTH, CANVASHEIGHT, null, transparent, antialias);

  canvascontainer.append(renderer.view);

  displaycanvaselem.hide();

  displaycanvaselem = $(renderer.view);

  canvasobj = renderer.view.getContext('2d');

  displaycanvaselem.mousedown(function(e) {
    if (e.button === 0) {
      mpos = correctpos(e);
      isdrawing = true;
    }
    if (e.button === 2) {
      holdingright = true;
      rdown(e);
    }
    return draw(mpos);
  });

  cancel = function(e) {
    if (e.button === 0) {
      isdrawing = false;
    }
    if (e.button === 2) {
      return holdingright = false;
    }
  };

  displaycanvaselem.mouseup(cancel);

  body.mouseup(cancel);

  correctpos = function(e) {
    var offset, screenpageoffset, x, y;
    screenpageoffset = V2d(e.screenX - e.pageX, e.screenY - e.pageY);
    x = e.pageX;
    y = e.pageY;
    offset = displaycanvaselem.offset();
    x -= offset.left;
    y -= offset.top;
    if (flipped) {
      x = displaycanvaselem.width() - x;
    }
    return V2d(x, y);
  };

  color = rgba(0, 0, 0, 1);

  displaycanvaselem.bind('contextmenu', function(e) {
    return false;
  });

  pickcolor = function(ctx, pos) {
    return rgba(0, 0, 0, 1);
  };

  rdown = function(e) {
    var coleur;
    mpos = correctpos(e);
    coleur = pickcolor(canvasobj, mpos);
    coleur = adjustalpha(coleur, color.a);
    return updatecolor(coleur);
  };

  prev = void 0;

  minradius = 1;

  maxradius = 10;

  lastdab = void 0;

  vnmul = function(v, n) {
    return V2d(v.x * n, v.y * n);
  };

  vadd = function(a, b) {
    return V2d(a.x + b.x, a.y + b.y);
  };

  vsub = function(a, b) {
    return V2d(a.x - b.x, a.y - b.y);
  };

  vmag = function(v) {
    return Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2));
  };

  vdist = function(a, b) {
    return vmag(vsub(a, b));
  };

  cancelright = function(e) {
    if (e.button === 2) {
      return holdingright = false;
    }
  };

  displaycanvaselem.mouseup(cancelright);

  updaterecentcolors = function() {
    var i;
    if (__indexOf.call(recentcolors, color) >= 0) {
      i = recentcolors.indexOf(color);
      recentcolors.splice(i, 1);
      recentcolors.unshift(color);
      updateswatches();
    }
    if (__indexOf.call(recentcolors, color) < 0) {
      recentcolors.unshift(color);
      updateswatches();
    }
    if (recentcolors.length > 8) {
      recentcolors.pop();
      return updateswatches();
    }
  };

  switchcolor = function() {
    updatecolor(recentcolors[1]);
    return updaterecentcolors();
  };

  bindings = {};

  keytapbind = function(key, func) {
    var k;
    k = key.toUpperCase().charCodeAt(0);
    bindings[k] = func;
    return body.append("<a accesskey=" + key + "></a>");
  };

  keytapbind('x', switchcolor);

  $(document).bind('keydown', function(e) {
    var key;
    if (!e.altKey) {
      return;
    }
    key = e.which;
    if (bindings.hasOwnProperty(key)) {
      return bindings[key]();
    }
  });

  tabletmodifier = function(st) {
    var adjustedopacitypressure, adjustedradiuspressure, c, f, newalpha, newst, penapi, pressure, radiusrange, t, w;
    penapi = wacom().penAPI;
    pressure = penapi.pressure;
    adjustedradiuspressure = Math.pow(pressure, 2);
    adjustedopacitypressure = Math.pow(pressure, 3);
    c = st.color;
    if (penapi.isEraser) {
      c = rgba(255, 255, 255, 1);
      pressure = 1;
    }
    w = st.width;
    f = st.from;
    t = st.to;
    radiusrange = maxradius - minradius;
    if (tabletaffectsradius) {
      w = minradius + radiusrange * adjustedradiuspressure;
    }
    if (tabletaffectsopacity) {
      newalpha = c.a * adjustedopacitypressure;
      c = adjustalpha(c, newalpha);
    }
    newst = $.extend({}, st, {
      from: f,
      to: t,
      width: w,
      color: c,
      brush: st.brush
    });
    if (penapi.isEraser) {
      newst.brush = 'eraser';
    }
    return newst;
  };

  draw = function(mpos) {
    var penapi, st;
    if ((!isdrawing) || displaycanvaselem.hasClass("disabled")) {
      prev = void 0;
      lastdab = void 0;
      return;
    }
    penapi = wacom().penAPI;
    if (!prev) {
      prev = mpos;
    }
    if (prev) {
      st = {
        from: prev,
        to: mpos,
        width: maxradius,
        color: color,
        brush: currentbrush
      };
      if (penapi) {
        st = tabletmodifier(st);
      }
      makestroke(st);
    }
    return prev = V2d(mpos.x, mpos.y);
  };

  displaycanvaselem.mousedown(function(e) {
    return updaterecentcolors();
  });

  displaycanvaselem.mousemove(function(e) {
    if (holdingright) {
      return rdown(e);
    }
  });

  body.mousemove(function(e) {
    mpos = correctpos(e);
    return draw(mpos);
  });

  csscolor = function(col) {
    return "rgba(" + col.r + "," + col.g + "," + col.b + "," + col.a + ")";
  };

  clumps = function(arr, n) {
    var i, x, _i, _len, _ref, _results;
    _ref = arr.slice(0, +(arr.length - n) + 1 || 9e9);
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      x = _ref[i];
      _results.push(arr.slice(i, i + n));
    }
    return _results;
  };

  degstorads = function(deg) {
    return (deg * Math.PI) / 180;
  };

  vmag = function(v) {
    return Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2));
  };

  vndiv = function(v, n) {
    return V2d(v.x / n, v.y / n);
  };

  vnorm = function(v) {
    return vndiv(v, vmag(v));
  };

  rfloat = function() {
    return -1 + Math.random() * 2;
  };

  randdir = function() {
    return vnorm(V2d(rfloat(), rfloat()));
  };

  randvector = function() {
    return vnmul(randdir(), Math.random());
  };

  brushpresets = {};

  brushpresets["default"] = {
    adjust: function(st, pos, angle) {
      var ellipseratio, jitter;
      jitter = 0;
      pos = vadd(pos, vnmul(randvector(), jitter * st.width));
      ellipseratio = 1;
      return {
        pos: pos,
        radius: st.width / 2,
        angle: angle,
        ellipseratio: ellipseratio,
        color: st.color
      };
    }
  };

  brushpresets.eraser = {
    adjust: function(st, pos, angle) {
      var ellipseratio;
      color = rgba(0, 0, 0, 1);
      ellipseratio = 1;
      return {
        pos: pos,
        radius: st.width / 2,
        angle: angle,
        ellipseratio: ellipseratio,
        color: color,
        erase: true
      };
    }
  };

  brushpresets.chalk = {
    adjust: function(st, pos, angle) {
      var ellipseratio, jitter, radius;
      jitter = 1 / 8;
      radius = st.width / 8;
      pos = vadd(pos, vnmul(randvector(), jitter * st.width));
      ellipseratio = 1;
      return {
        pos: pos,
        radius: radius,
        angle: angle,
        ellipseratio: ellipseratio,
        color: st.color
      };
    }
  };

  brushpresets.spatter = {
    adjust: function(st, pos, angle) {
      var ellipseratio, jitter, radius, tmpcolor;
      jitter = 1;
      radius = st.width * Math.random() / 10;
      tmpcolor = st.color;
      pos = vadd(pos, vnmul(randvector(), jitter * st.width));
      ellipseratio = 1;
      return {
        pos: pos,
        radius: radius,
        angle: angle,
        ellipseratio: ellipseratio,
        color: tmpcolor
      };
    }
  };

  brushpresets.bristles = {
    adjust: function(st, pos, angle) {
      var ellipseratio, jitter, radius, speed, tmpcolor;
      speed = vmag(vsub(st.to, st.from));
      jitter = 1 / 2;
      tmpcolor = st.color;
      pos = vadd(pos, vnmul(randvector(), jitter * st.width));
      ellipseratio = 0.1;
      radius = st.width * 2 / 3;
      angle += Math.PI / 2;
      return {
        pos: pos,
        radius: radius,
        angle: angle,
        ellipseratio: ellipseratio,
        color: tmpcolor
      };
    }
  };

  brushpresets.directionalbrush = {
    adjust: function(st, pos, angle) {
      var ellipseratio, tmpcolor;
      tmpcolor = st.color;
      ellipseratio = 0.1;
      return {
        pos: pos,
        radius: st.width / 2,
        angle: angle,
        ellipseratio: ellipseratio,
        color: tmpcolor
      };
    }
  };

  brushpresets.noise = {
    adjust: function(st, pos, angle) {
      var ellipseratio, jitter, radius, tmpcolor;
      jitter = 1;
      radius = st.width * Math.random() / 10;
      tmpcolor = pickcolor(canvasobj, pos);
      tmpcolor = adjustalpha(tmpcolor, 1);
      pos = vadd(pos, vnmul(randvector(), jitter * st.width));
      ellipseratio = 1;
      return {
        pos: pos,
        radius: radius,
        angle: angle,
        ellipseratio: ellipseratio,
        color: tmpcolor
      };
    }
  };

  brushpresets.smudge = {
    adjust: function(st, pos, angle) {
      var ellipseratio, jitter, tmpcolor;
      jitter = 0;
      tmpcolor = pickcolor(canvasobj, pos);
      tmpcolor = adjustalpha(tmpcolor, 0.1);
      pos = vadd(pos, vnmul(randvector(), jitter * st.width));
      ellipseratio = 1;
      return {
        pos: pos,
        radius: st.width / 2,
        angle: angle,
        ellipseratio: ellipseratio,
        color: tmpcolor
      };
    }
  };

  brushpresets.wetpaint = {
    adjust: function(st, pos, angle) {
      var ellipseratio, jitter, tmpcolor;
      jitter = 0;
      tmpcolor = pickcolor(canvasobj, pos);
      tmpcolor = adjustalpha(tmpcolor, 0.5);
      pos = vadd(pos, vnmul(randvector(), jitter * st.width));
      ellipseratio = 0.4;
      return {
        pos: pos,
        radius: st.width / 2,
        angle: angle,
        ellipseratio: ellipseratio,
        color: tmpcolor
      };
    }
  };

  pixicolor = function(rgba) {
    return rgba.r * 256 * 256 + rgba.g * 256 + rgba.b;
  };

  jqbrush = $("<canvas>");

  jqbrush.attr({
    width: 32,
    height: 32
  });

  brushcanvas = jqbrush.get(0);

  context = brushcanvas.getContext('2d');

  context.beginPath();

  rad = 16;

  context.arc(0, 0, rad, 0, 2 * Math.PI, false);

  context.fillStyle = 'orange';

  context.fill();

  brushtexture = PIXI.Texture.fromCanvas(brushcanvas);

  drawstroke = function(st) {
    var FRAC, brush, dabcount, dabz, dir, radiusperdab, strokediff, strokedirection, threshold, _i, _results;
    radiusperdab = 1 / 3;
    threshold = st.width * radiusperdab;
    FRAC = vdist(st.from, st.to) / st.width;
    dabcount = Math.ceil(vdist(st.from, st.to) / threshold);
    dabcount = Math.max(2, dabcount);
    dir = vsub(st.to, st.from);
    dabz = (function() {
      _results = [];
      for (var _i = 1; 1 <= dabcount ? _i <= dabcount : _i >= dabcount; 1 <= dabcount ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(function(n) {
      var c, offs;
      c = n / dabcount;
      offs = vnmul(dir, c);
      return vadd(st.from, offs);
    });
    strokediff = vsub(st.from, st.to);
    strokedirection = Math.atan2(strokediff.y, strokediff.x);
    brush = brushpresets[st.brush] || brushpresets["default"];
    return dabz.forEach(function(dab) {
      var alpha, grof, newdab, tmprad;
      newdab = brush.adjust(st, dab, strokedirection);
      alpha = newdab.color.a;
      stage.addChild(grof = new PIXI.Graphics());
      grof.beginFill(pixicolor(newdab.color), alpha);
      tmprad = newdab.radius * newdab.ellipseratio;
      grof.drawElipse(0, 0, newdab.radius * newdab.ellipseratio, newdab.radius);
      grof.rotation = newdab.angle;
      return grof.position = new PIXI.Point(newdab.pos.x, newdab.pos.y);
    });
  };

  makestroke = function(st) {
    var col, from, r, strokedata, to;
    from = st.from;
    to = st.to;
    r = st.width;
    col = st.color;
    strokedata = st;
    cache.push(strokedata);
    if (socket) {
      return socket.emit('stroke', strokedata);
    }
  };

  toolbar = $("<div id=toolbar>");

  toolbar.css({
    position: 'relative',
    overflow: 'auto',
    height: '100%'
  });

  contain.append(toolbar);

  header = function(str) {
    return $(tag("h3", str));
  };

  label = function(str) {
    return $(tag("label", str));
  };

  toolbar.append(header("brush"));

  toolbar.append(container = $("<div>"));

  container.append(brushselection = $("<select>"));

  for (k in brushpresets) {
    v = brushpresets[k];
    brushselection.append(tag("option", k));
  }

  brushselection.change(function(e) {
    return currentbrush = this.value;
  });

  brushselection.css({
    'display': 'block'
  });

  container.append(lab = label("size"));

  lab.attr({
    'for': 'radiusslider'
  });

  radiusslider = $("<div id=radiusslider></div>");

  radiusslider.slider({
    min: ABSMINRADIUS,
    max: ABSMAXRADIUS,
    range: true,
    slide: function(e, ui) {
      minradius = ui.values[0];
      return maxradius = ui.values[1];
    }
  });

  container.append(radiusslider);

  brushsizedelta = function(delta) {
    maxradius = maxradius + delta;
    maxradius = Math.max(maxradius, ABSMINRADIUS);
    maxradius = Math.min(maxradius, ABSMAXRADIUS);
    return radiusslider.slider('values', minradius, maxradius);
  };

  brushsizeup = function() {
    return brushsizedelta(1);
  };

  brushsizedown = function() {
    return brushsizedelta(-1);
  };

  keytapbind('z', brushsizedown);

  keytapbind('a', brushsizeup);

  container.append(label('opacity'));

  alphaslider = $("<div>");

  alphaslider.slider({
    min: 0,
    max: 1,
    step: 0.01,
    value: 1,
    slide: function(e, ui) {
      return updatecolor(rgba(color.r, color.g, color.b, ui.value));
    }
  });

  container.append(alphaslider);

  toolbar.append(header("color"));

  toolbar.append(colorpicker = $("<div>"));

  colorpicker.addClass('colorpicker');

  colorslider = function() {
    var sliderelem;
    sliderelem = $("<div>");
    sliderelem.slider({
      min: 1,
      max: 255,
      range: 'min'
    });
    sliderelem.css({
      height: 50,
      display: 'inline-block'
    });
    return sliderelem;
  };

  redslider = colorslider().slider({
    orientation: 'vertical',
    slide: function(e, ui) {
      return updatecolor(rgba(ui.value, color.g, color.b, color.a));
    }
  });

  greenslider = colorslider().slider({
    orientation: 'vertical',
    slide: function(e, ui) {
      return updatecolor(rgba(color.r, ui.value, color.b, color.a));
    }
  });

  blueslider = colorslider().slider({
    orientation: 'vertical',
    slide: function(e, ui) {
      return updatecolor(rgba(color.r, color.g, ui.value, color.a));
    }
  });

  redslider.addClass('red');

  greenslider.addClass('green');

  blueslider.addClass('blue');

  colorbox = $("<div>&nbsp;</div>");

  colorbox.css({
    height: 32,
    width: 32,
    float: 'right'
  });

  colorpicker.append("<ul><li><a href='#rgbpick'>rgb</a></li><li><a href='#wheelpick'>wheel</a></li></ul>");

  colorpicker.append(rgbpicker = $("<div id=rgbpick>"));

  rgbpicker.append(colorbox);

  colorpicker.addClass('colorpicker');

  rgbpicker.append(redslider, greenslider, blueslider);

  colorpicker.append(colorwheeldom = $("<div id=wheelpick>"));

  colorwheel = Raphael.colorwheel(colorwheeldom, 128);

  colorpicker.tabs();

  updatecolor = function(col) {
    color = col;
    redslider.slider({
      value: color.r
    });
    greenslider.slider({
      value: color.g
    });
    blueslider.slider({
      value: color.b
    });
    alphaslider.slider({
      value: color.a
    });
    colorbox.css("background", csscolor(color));
    return colorwheel.color(csscolor(color));
  };

  spuncolorwheel = function(col) {
    color = col;
    redslider.slider({
      value: color.r
    });
    greenslider.slider({
      value: color.g
    });
    blueslider.slider({
      value: color.b
    });
    alphaslider.slider({
      value: color.a
    });
    return colorbox.css("background", csscolor(color));
  };

  round = Math.round;

  colorwheel.onchange(function(rcol) {
    var nc;
    nc = rgba(round(rcol.r), round(rcol.g), round(rcol.b), color.a);
    return spuncolorwheel(nc);
  });

  swatches = $("<div></div>");

  colorpicker.append(swatches);

  updateswatches = function() {
    var x;
    x = recentcolors.map(function(col) {
      var but;
      but = $(tag("button"));
      but.css({
        "background": csscolor(col)
      });
      but.button();
      but.css({
        width: 20,
        height: 20
      });
      return but.click(function() {
        return updatecolor(col);
      });
    });
    swatches.html('');
    return swatches.append(x);
  };

  clearctx = function(ctx) {
    return ctx.clearRect(0, 0, CANVASWIDTH, CANVASHEIGHT);
  };

  clearcanvas = function() {};

  lastframe = 0;

  startreplay = function() {
    clearcanvas();
    lastframe = 0;
    return false;
  };

  strokespertick = 1;

  disablecanvas = function() {
    return displaycanvaselem.addClass("disabled");
  };

  enablecanvas = function() {
    return displaycanvaselem.removeClass("disabled");
  };

  timecall = function(func) {
    var starttime;
    starttime = Date.now();
    func();
    return Date.now() - starttime;
  };

  stagecount = 0;

  replaytick = function() {
    var base, curr, starttime, tex, x, _i;
    if (lastframe === cache.length) {
      if (nocache && cache.length > 100) {
        clearlocalcache();
      }
      enablecanvas();
      return;
    }
    if (stagecount > 100) {
      stagecount = 0;
      tex = new PIXI.RenderTexture(CANVASWIDTH, CANVASHEIGHT);
      tex.render(stage);
      base = new PIXI.Sprite(tex);
      stage = new PIXI.Stage(0xFFFFFF, true);
      stage.addChild(base);
    }
    displaycanvasctx.drawImage(renderer.view, 0, 0);
    if (lastframe === 0 && cache.length > 3) {
      disablecanvas();
    }
    starttime = Date.now();
    if (cache.length > lastframe) {
      for (x = _i = 0; 0 <= strokespertick ? _i <= strokespertick : _i >= strokespertick; x = 0 <= strokespertick ? ++_i : --_i) {
        stagecount++;
        if (lastframe === cache.length) {
          break;
        }
        curr = cache[lastframe];
        drawstroke(curr);
        lastframe++;
      }
    }
    return timebar.progressbar({
      value: lastframe,
      max: cache.length
    });
  };

  luup = function() {
    replaytick();
    requestAnimFrame(function() {
      return renderer.render(stage);
    });
    return setTimeout(luup, 5);
  };

  luup();

  cursoroncanvas = false;

  displaycanvaselem.mouseenter(function() {
    return cursoroncanvas = true;
  });

  displaycanvaselem.mouseout(function() {
    return cursoroncanvas = false;
  });

  networkcursors = [];

  assembleimg = function() {
    clearctx(displaycanvasctx);
    displaycanvasctx.fillStyle = 'white';
    return displaycanvasctx.fillRect(0, 0, CANVASWIDTH, CANVASHEIGHT);
  };

  drawloop = function() {
    var idealms;
    idealms = 1;
    if (!paused) {
      replaytick(lastframe);
    }
    if (cursoroncanvas) {
      drawcursor(mpos, color, maxradius);
      drawcursor(mpos, color, minradius);
    }
    networkcursors.forEach(function(c) {
      return c();
    });
    networkcursors = [];
    return setTimeout(drawloop, idealms);
  };

  drawcursor = function(pos, col, rad) {
    var dcc;
    dcc = displaycanvasctx;
    dcc.beginPath();
    dcc.arc(pos.x, pos.y, rad / 2, 0, 2 * Math.PI, false);
    dcc.lineWidth = 1;
    dcc.fillStyle = 'none';
    dcc.strokeStyle = csscolor(adjustalpha(col, 1 / 2));
    return dcc.stroke();
  };

  skipreplay = function() {
    tolast();
    return false;
  };

  keytapbind('k', skipreplay);

  tolast = function() {
    var _results;
    _results = [];
    while (cache.length > lastframe) {
      _results.push(replaytick());
    }
    return _results;
  };

  skipbutton = $("<button>\"skip\" replay (may cause a huge delay)</button>");

  skipbutton.click(skipreplay);

  skipbutton.button({
    icons: {
      primary: "ui-icon-seek-end"
    },
    text: true
  });

  archiveurl = "./files/archive/20130904.json.txt";

  loadarchivedsession = function(url) {
    log("downloading session...");
    return $.get(url, (function(data, textstatus, jqxhr) {
      var fcount;
      cache = data;
      fcount = cache.length;
      log("cache loaded, " + fcount + " strokes.");
      return startreplay();
    }), 'json');
  };

  archivebutton = $(tag("button", "view an archived session"));

  archivebutton.click(function() {
    alert("keep in mind this just affects your local replay, any new doodling that happens wll be sent to the current active session \n  TODO: fix this");
    return loadarchivedsession(archiveurl);
  });

  archivebutton.button();

  replayspeed = $("<div>");

  replayspeed.css({
    'width': 100
  });

  replayspeed.slider({
    min: 1,
    max: 200,
    slide: (function(e, ui) {
      return strokespertick = ui.value;
    })
  });

  loadsession = function() {
    log("downloading session...");
    return $.get('/getsession', (function(data, textstatus, jqxhr) {
      var fcount;
      cache = data;
      fcount = cache.length;
      log("cache loaded, " + fcount + " strokes.");
      return startreplay();
    }), 'json');
  };

  toolbar.append(header("tablet (wacom driver)"));

  toolbar.append(container = $("<div>"));

  container.append(label("pressure affects..."));

  container.append($("<input type=checkbox id=pressure /><label for=pressure>size</label>"));

  container.append($("<input type=checkbox id=opacity /><label for=opacity>opacity</label>"));

  $('#pressure').change(function() {
    return tabletaffectsradius = this.checked;
  });

  $('#opacity').change(function() {
    return tabletaffectsopacity = this.checked;
  });

  toolbar.append(header("misc"));

  toolbar.append(container = $("<div>"));

  container.append(label("export "));

  exportpng = function() {
    var url;
    assembleimg();
    url = displaycanvaselem.get(0).toDataURL("image/png");
    return window.open(url);
  };

  keytapbind('p', exportpng);

  keytapbind('r', startreplay);

  savebutton = $(tag("button", ".png snapshot"));

  savebutton.click(function() {
    return exportpng();
  });

  savebutton.button();

  container.append(savebutton);

  exportsvg = function() {
    var data;
    data = "";
    data += "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewbox='0 0 1000 600'>";
    data += cache.map(function(s) {
      return "<line x1='" + s.from.x + "' y1='" + s.from.y + "' x2='" + s.to.x + "' y2='" + s.to.y + "' stroke='" + (csscolor(s.color)) + "' stroke-width='" + s.width + "' stroke-linecap='round' />";
    }).join();
    data += "</svg>";
    window.open(dataurl(data));
    return false;
  };

  savebutton = $(tag("button", ".svg"));

  savebutton.click(function() {
    return exportsvg();
  });

  savebutton.button();

  container.append(savebutton);

  exportjson = function() {
    return window.open("/getsession");
  };

  savebutton = $(tag("button", ".json"));

  savebutton.click(function() {
    return exportjson();
  });

  savebutton.button();

  container.append(savebutton);

  flipped = false;

  toggleflip = function() {
    flipped = !flipped;
    if (flipped) {
      return displaycanvaselem.addClass('flipped');
    } else {
      return displaycanvaselem.removeClass('flipped');
    }
  };

  flipbutton = $(tag("button", "flip canvas view"));

  flipbutton.click(toggleflip);

  flipbutton.button();

  container.append(flipbutton);

  keytapbind('i', toggleflip);

  bombsahoy = function() {
    cache = [];
    startreplay();
    return log("BOMBS AHOY");
  };

  bombbutton = $(tag("button", "BOMB"));

  bombbutton.click(function() {
    if (!(confirm('really?') && confirm("are you super sure? this will nuke the contents of the canvas straight off the face of the earth"))) {
      return false;
    }
    bombsahoy();
    socket.emit('bomb');
    return false;
  });

  bombbutton.button();

  bombbutton.css({
    'font-size': 10,
    'margin-top': 20,
    color: 'darkred',
    display: 'block'
  });

  container.append(bombbutton);

  container.append(ll = label("big friendly global thermonuclear annihilation button, pressing it will destroy the canvas contents"));

  ll.css({
    color: 'gray'
  });

  $.fn.togglepanels = function() {
    return this.each(function() {
      return $(this).addClass("ui-accordion ui-accordion-icons ui-widget ui-helper-reset").find("h3").addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-top ui-corner-bottom").hover(function() {
        return $(this).toggleClass("ui-state-hover");
      }).prepend('<span class="ui-icon ui-icon-triangle-1-e"></span>').click(function() {
        $(this).toggleClass("ui-accordion-header-active ui-state-active ui-state-default ui-corner-bottom").find("> .ui-icon").toggleClass("ui-icon-triangle-1-e ui-icon-triangle-1-s").end().next().slideToggle();
        return false;
      }).next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom").hide();
    });
  };

  toolbar.css({
    'float': 'left',
    width: '150px'
  });

  toolbar.insertBefore(canvascontainer);

  opentoolbar = function() {
    return toolbar.dialog('open');
  };

  replaycontrols = $("<div id=replaycontrols>");

  replaycontrols.css({
    clear: 'left'
  });

  body.append(replaycontrols);

  pausebutton = $("<button>pause/unpause replay</button>");

  pausebutton.button({
    icons: {
      primary: "ui-icon-pause"
    },
    text: true
  });

  pausebutton.click(function() {
    return paused = !paused;
  });

  replaybutton = $("<button>restart replay</button>");

  replaybutton.button({
    icons: {
      primary: "ui-icon-seek-first"
    },
    text: true
  });

  replaybutton.click(startreplay);

  replayspeed.css({
    'margin': 5,
    float: 'left'
  });

  timebar = $("<div></div>");

  replaycontrols.append("<label>replay speed</label>");

  replaycontrols.append(replayspeed);

  replaycontrols.append(skipbutton);

  cachebutton = $("<button>clear local replay cache</button>");

  clearlocalcache = function() {
    cache = [];
    return lastframe = 0;
  };

  cachebutton.click(clearlocalcache);

  cachebutton.button();

  replaycontrols.append(pausebutton, replaybutton);

  replaycontrols.append(archivebutton);

  tickbutton = $("<button>advance one tick</button>");

  tickbutton.click(replaytick);

  replaycontrols.append(tickbutton);

  replaycontrols.append($("<input type=checkbox id=nocache /><label for=nocache>clear cache automagically</label>"));

  $('#nocache').change(function() {
    return nocache = this.checked;
  });

  replaycontrols.append("&middot;");

  replaycontrols.append($("<div id='hotkeyinfo'></div>"));

  listdata = ["i - flip canvas", "a/z - change brush size", "x - swap color", "p - png snapshot", "r - replay", "k - skip replay (takes a while)"].map(function(x) {
    return tag("li", x);
  });

  $("#hotkeyinfo").append("Hold alt and press one of the following:\n" + tag("ul", listdata.join("")));

  $("#hotkeyinfo").hide();

  replaycontrols.append(but = $(tag("button", "hotkey info")));

  but.button({
    icons: {
      primary: "ui-icon-help"
    },
    text: true
  });

  but.click(function() {
    return $("#hotkeyinfo").dialog();
  });

  replaycontrols.append(timebar);

  info = $("<div>");

  info.css({
    width: '100%',
    background: 'white',
    font: 'sans-serif',
    overflow: 'scroll',
    height: '300px'
  });

  zeropad = function(num) {
    if (num < 10) {
      return '0' + num;
    }
    return String(num);
  };

  infoprepend = function(text) {
    var hh, mm, now, ss, timestamp;
    now = new Date;
    hh = zeropad(now.getHours());
    mm = zeropad(now.getMinutes());
    ss = zeropad(now.getSeconds());
    timestamp = "" + hh + ":" + mm + ":" + ss;
    text = timestamp + "|&nbsp;" + text;
    return info.prepend(text);
  };

  timelog = function(time, text) {
    var hh, mm, ss, timestamp;
    hh = zeropad(time.getHours());
    mm = zeropad(time.getMinutes());
    ss = zeropad(time.getSeconds());
    timestamp = "" + hh + ":" + mm + ":" + ss;
    text = timestamp + "|&nbsp;" + text;
    return info.prepend(text);
  };

  weekdays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];

  datelog = function(time) {
    var dd, mm, stuff, timestamp, weekday, yyyy;
    dd = zeropad(time.getUTCDate());
    mm = zeropad(time.getUTCMonth() + 1);
    yyyy = time.getUTCFullYear();
    weekday = weekdays[time.getUTCDay()];
    timestamp = "" + yyyy + "/" + mm + "/" + dd + " (" + weekday + ")";
    stuff = $(tag("div", timestamp));
    stuff.css({
      color: 'salmon',
      'border-bottom': '1px solid salmon'
    });
    return info.prepend(stuff);
  };

  htmlencode = function(str) {
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  };

  prevtime = 0;

  someonesaid = function(timems, name, text) {
    var hue, oldrandom, time;
    time = new Date(timems);
    if (timems - prevtime > 1000 * 60 * 60) {
      datelog(time);
    }
    oldrandom = Math.random;
    Math.seedrandom(name);
    hue = Math.random() * 360;
    Math.random = oldrandom;
    timelog(time, "<span style=\"color: hsl(" + hue + ",50%,50%)\">" + (htmlencode(name)) + "></span> " + (htmlencode(text)) + "<br/>\n");
    return prevtime = timems;
  };

  chatname = false;

  say = function(text) {
    var time;
    if (!chatname) {
      chatname = prompt("pick a name", 'anon');
    }
    if (!chatname) {
      return;
    }
    text = chatinput.val();
    time = new Date().getTime();
    someonesaid(time, chatname, text);
    return socket.emit('say', {
      name: chatname,
      text: text,
      time: time
    });
  };

  chatbox = $("<form>");

  chatbox.css({
    margin: 0
  });

  chatbox.submit(function() {
    say(chatinput.val());
    chatinput.val('');
    return false;
  });

  body.append(chatbox);

  chatbox.append(chatinput = $("<input type='text' placeholder='type words here'>"));

  chatinput.css({
    'width': '100%'
  });

  chatinput;

  body.append(info);

  info.css({
    'user-select': 'text'
  });

  skipbutton.css({
    'float': 'right'
  });

  log = function(text) {
    return infoprepend("**" + text + "<br/>\n");
  };

  loadchat = function() {
    return $.get('/chatlog', (function(data, textstatus, jqxhr) {
      var datum, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        datum = data[_i];
        _results.push(someonesaid(datum.time, datum.name, datum.text));
      }
      return _results;
    }), 'json');
  };

  $(document).ready(function() {
    loadsession();
    loadchat();
    disablecanvas();
    luup();
    brushsizedelta(0);
    updateswatches();
    if (NETWORKED) {
      socket = io.connect('/');
      socket.on('stroke', function(data) {
        cache.push(data);
        return networkcursors.push(function() {
          return drawcursor(data.to, rgba(0, 0, 0, 1 / 2), data.width);
        });
      });
      socket.on('say', function(data) {
        return someonesaid(data.time, data.name, data.text);
      });
      return socket.on('bomb', function(data) {
        return bombsahoy();
      });
    }
  });

  updatecolor(rgba(0, 0, 0, 1));

}).call(this);
